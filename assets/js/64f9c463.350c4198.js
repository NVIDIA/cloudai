"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[918],{5080:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>d});var o=s(4848),r=s(8453);const c={id:"concepts"},i="Concepts",t={id:"dev/concepts",title:"Concepts",description:"Runner, Scenario and ScenarioIter",source:"@site/../docs/dev/concepts.mdx",sourceDirName:"dev",slug:"/dev/concepts",permalink:"/cloudai/docs/dev/concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/NVIDIA/cloudai/edit/main/website/../docs/dev/concepts.mdx",tags:[],version:"current",frontMatter:{id:"concepts"}},a={},d=[{value:"<code>Runner</code>, <code>Scenario</code> and <code>ScenarioIter</code>",id:"runner-scenario-and-scenarioiter",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"concepts",children:"Concepts"})}),"\n",(0,o.jsxs)(n.h2,{id:"runner-scenario-and-scenarioiter",children:[(0,o.jsx)(n.code,{children:"Runner"}),", ",(0,o.jsx)(n.code,{children:"Scenario"})," and ",(0,o.jsx)(n.code,{children:"ScenarioIter"})]}),"\n",(0,o.jsxs)(n.p,{children:["Each ",(0,o.jsx)(n.code,{children:"System"})," should have a ",(0,o.jsx)(n.code,{children:"Runner"})," class that is responsible for running tasks. It includes task submission, monotoring and killing. ",(0,o.jsx)(n.code,{children:"TestScenario"})," describes tasks for running. In basic case, it is a static list loaded from a Scenario TOML config. ",(0,o.jsx)(n.code,{children:"ScenarioIter"})," is a glue between ",(0,o.jsx)(n.code,{children:"Runner"})," and ",(0,o.jsx)(n.code,{children:"Scenario"}),". It is responsible for task generation."]}),"\n",(0,o.jsxs)(n.p,{children:["Here is how a ",(0,o.jsx)(n.code,{children:"Runner"})," loop can look like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"while scenario_iter.has_more_tasks:\n    for tr in scenario_iter:\n        runner.submit_task(tr)\n    \n    for tr in active_tasks:\n        if runner.is_task_done(tr):\n            scenario_iter.on_completed(tr, runner)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Two things to notice:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ScenarioIter.has_more_tasks"})," should be checked to ensure if there are more tasks to run."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ScenarioIter"})," is an iterator, it should be re-created (a new loop should start) to fetch new cases."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ScenarioIter"})," has interface to be notified about task running change, for example, ",(0,o.jsx)(n.code,{children:"on_completed"})," method is used to notify about task completion."]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["Two loops and ",(0,o.jsx)(n.code,{children:"has_more_tasks"})," allow asyncronous task management without actual asyncronous code. New tasks can be added based on status of currently active or finished tasks."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);