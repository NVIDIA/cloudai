# SPDX-FileCopyrightText: NVIDIA CORPORATION & AFFILIATES
# Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
from pathlib import Path
from typing import Any, Dict, List

from cloudai import CommandGenStrategy, TestRun
from cloudai.systems.slurm.slurm_system import SlurmSystem


class DeepEPBenchmarkSlurmCommandGenStrategy(CommandGenStrategy):
    """Command generation strategy for DeepEP benchmark on Slurm systems."""

    def gen_exec_command(self, tr: TestRun) -> str:
        """
        Generate the Slurm execution command for DeepEP benchmark.

        Args:
            tr (TestRun): Contains the test and its run-specific configurations.

        Returns:
            str: The generated execution command (sbatch script path).
        """
        slurm_args = self._parse_slurm_args("deepep", tr.test.extra_env_vars, tr.test.extra_cmd_args)
        srun_command = self.gen_srun_command(tr)
        return self._write_sbatch_script(tr, slurm_args, srun_command)

    def gen_srun_command(self, tr: TestRun) -> str:
        """
        Generate the srun command for DeepEP benchmark.

        Args:
            tr (TestRun): Contains the test and its run-specific configurations.

        Returns:
            str: The generated srun command.
        """
        cmd_args = tr.test.cmd_args
        
        # Parse nodes to get actual count
        parsed_nodes = self.system.parse_nodes(tr.nodes) if tr.nodes else []
        num_nodes = len(parsed_nodes) if parsed_nodes else tr.num_nodes
        
        # Generate config YAML content
        config_content = self._generate_config_yaml(cmd_args)
        
        # Write config to temporary file
        config_file_path = tr.output_path / "config.yaml"
        with open(config_file_path, 'w') as f:
            f.write(config_content)
        
        # Determine which benchmark script to run based on mode
        if cmd_args['mode'] == 'standard':
            benchmark_script = '/workspace/dp-benchmark/benchmark/benchmark.py'
        else:  # low_latency
            benchmark_script = '/workspace/dp-benchmark/benchmark/benchmark_ll.py'
        
        # Get the installed Docker image path (handles both URLs and local .sqsh files)
        docker_image_path = tr.test.test_definition.docker_image.installed_path
        
        # Build container mounts
        # Mount results directory and config file
        results_dir = tr.output_path.absolute()
        mounts = [
            f"{results_dir}:{cmd_args['results_dir']}",
            f"{config_file_path.absolute()}:{cmd_args['config_file_path']}"
        ]
        container_mounts = ",".join(mounts)
        
        # Build srun command
        srun_command_parts = [
            "srun",
            "--export=ALL",
            f"--container-image={docker_image_path}",
            f"--container-mounts={container_mounts}",
            "torchrun",
            f"--nnodes={num_nodes}",
            "--nproc_per_node=1",
            f"--rdzv_id=$RANDOM",
            "--rdzv_backend=c10d",
            "--rdzv_endpoint=$head_node_ip:29500",
            benchmark_script,
            cmd_args['config_file_path']
        ]
        
        return " \\\n    ".join(srun_command_parts)

    def _generate_config_yaml(self, cmd_args: Dict[str, Any]) -> str:
        """
        Generate YAML configuration content for DeepEP benchmark.

        Args:
            cmd_args: Command arguments dictionary.

        Returns:
            str: YAML configuration content.
        """
        config_lines = [
            "# DeepEP Benchmark Configuration",
            "# Generated by CloudAI",
            "",
            f"tokens: {cmd_args['tokens']}",
            f"num_experts: {cmd_args['num_experts']}",
            f"num_topk: {cmd_args['num_topk']}",
            f"hidden_size: {cmd_args['hidden_size']}",
            f"data_type: \"{cmd_args['data_type']}\"",
            f"allow_nvlink_for_low_latency: {str(cmd_args['allow_nvlink_for_low_latency']).lower()}",
            f"allow_mnnvl: {str(cmd_args['allow_mnnvl']).lower()}",
            f"round_scale: {str(cmd_args['round_scale']).lower()}",
            f"use_ue8m0: {str(cmd_args['use_ue8m0']).lower()}",
            f"shuffle_columns: {str(cmd_args['shuffle_columns']).lower()}",
            f"use_kineto_profiler: {str(cmd_args['use_kineto_profiler']).lower()}",
            f"num_warmups: {cmd_args['num_warmups']}",
            f"num_iterations: {cmd_args['num_iterations']}",
        ]
        
        return "\n".join(config_lines)

    def _parse_slurm_args(
        self, job_name_prefix: str, env_vars: Dict[str, str], extra_cmd_args: Dict[str, str]
    ) -> Dict[str, Any]:
        """
        Parse Slurm arguments from environment variables and extra command arguments.

        Args:
            job_name_prefix: Prefix for the job name.
            env_vars: Environment variables.
            extra_cmd_args: Extra command arguments.

        Returns:
            dict: Parsed Slurm arguments.
        """
        assert isinstance(self.system, SlurmSystem), "System must be a SlurmSystem"
        
        slurm_args = {
            "image_path": "",
            "container_mounts": "",
        }

        return slurm_args

    def _write_sbatch_script(self, tr: TestRun, slurm_args: Dict[str, Any], srun_command: str) -> str:
        """
        Write the sbatch script to a file and return its path.

        Args:
            tr (TestRun): Test run configuration.
            slurm_args: Slurm arguments.
            srun_command: The srun command to execute.

        Returns:
            str: Path to the generated sbatch script.
        """
        assert isinstance(self.system, SlurmSystem), "System must be a SlurmSystem"
        
        tr.output_path.mkdir(parents=True, exist_ok=True)
        script_path = tr.output_path / "deepep_sbatch_script.sh"
        
        cmd_args = tr.test.cmd_args
        
        # Parse nodes to get actual node names and count
        parsed_nodes = self.system.parse_nodes(tr.nodes) if tr.nodes else []
        num_nodes = len(parsed_nodes) if parsed_nodes else tr.num_nodes
        node_list_str = ",".join(parsed_nodes) if parsed_nodes else ""
        
        # Build sbatch script
        script_lines = [
            "#!/bin/bash",
            f"#SBATCH --job-name=cloudai_{tr.test.name}",
            f"#SBATCH -N {num_nodes}",
            f"#SBATCH --ntasks-per-node=1",
            f"#SBATCH --gpus-per-node={self.system.gpus_per_node}",
        ]
        
        # Add time limit if specified
        if tr.time_limit:
            script_lines.append(f"#SBATCH --time={tr.time_limit}")
        
        # Add partition if specified
        if self.system.default_partition:
            script_lines.append(f"#SBATCH --partition={self.system.default_partition}")
        
        # Add nodes list if specified
        if node_list_str:
            script_lines.append(f"#SBATCH --nodelist={node_list_str}")
        
        script_lines.extend([
            "",
            "# Get head node information",
            "nodes=( $( scontrol show hostnames $SLURM_JOB_NODELIST ) )",
            "nodes_array=($nodes)",
            "head_node=${nodes_array[0]}",
            'head_node_ip=$(srun --nodes=1 --ntasks=1 -w "$head_node" hostname --ip-address)',
            "",
            "echo Nodes: $SLURM_JOB_NODELIST",
            "echo Num Nodes: ${#nodes[@]}",
            "echo Head Node IP: $head_node_ip",
            "",
        ])
        
        # Add global env vars from system config
        if self.system.global_env_vars:
            script_lines.append("")
            script_lines.append("# System global environment variables")
            for key, value in self.system.global_env_vars.items():
                script_lines.append(f"export {key}={value}")
        
        script_lines.extend([
            "",
            "# Execute DeepEP benchmark",
            srun_command
        ])
        
        # Write script to file
        with open(script_path, 'w') as f:
            f.write("\n".join(script_lines))
        
        os.chmod(script_path, 0o755)
        
        return f"sbatch {script_path}"

